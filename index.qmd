---
title: "Selection Bias & Missing Data Challenge"
subtitle: "Creating a Statistics Meme: Write Your Own Functions"
format:
  html: default
execute:
  echo: false
  eval: true
---

# üé® Selection Bias & Missing Data Challenge

::: {.callout-important}
## üìä Challenge Overview

**Your Task:** Create a four-panel statistics meme demonstrating selection bias. You'll write three Python functions yourself to complete the workflow, then assemble them into a professional meme.

**Deliverables:**

1. Three Python functions you write yourself:
   - `step4_create_block_letter.py` - Create a block letter "S" matching image dimensions
   - `step5_create_masked.py` - Apply the letter mask to the stippled image
   - `create_meme.py` - Assemble all components into the four-panel meme
2. A complete `index.qmd` file that uses all functions to generate your meme
3. Your final statistics meme (as a PNG file) using your own image

**Key Learning:** This challenge teaches you to write modular Python functions and assemble them into a complete workflow. You'll learn to structure code professionally and create a memorable visual representation of selection bias.

**Repository Information:**

- **Source/Starter File:** Available in the main repository at [https://github.com/flyaflya/selectionBiasChallenge](https://github.com/flyaflya/selectionBiasChallenge)
- **Challenge Read Online:** View the challenge instructions at [https://flyaflya.github.io/selectionBiasChallenge](https://flyaflya.github.io/selectionBiasChallenge)
- **Your Submission:** Fork this challenge and create your GitHub Pages site at `https://[your-username].github.io/selectionBiasChallenge/`
:::

## The Problem: Visualizing Selection Bias

Selection bias occurs when observed data isn't representative of the population. Your meme will demonstrate this concept through visual metaphor:

- **Reality**: Your original image represents the true population
- **Your Model**: Your stippled image represents your data collection (sampling)
- **Selection Bias**: A bold letter "S" represents a systematic pattern of missing data
- **Estimate**: Stippled image with "S" mask applied shows the biased estimate‚Äîwhat you see when selection bias removes data points in a systematic pattern

**Key Concept:** Images are simply matrices‚Äî2D arrays where each value represents a pixel (0.0 = black, 1.0 = white). Your stippled image is a matrix with black dots (data points) on a white background. Selection bias removes some of these pixels (data points) in a systematic pattern (the "S"), creating a biased estimate.

**Key Insight:** When data is missing in a systematic pattern (not random), your estimates become biased. The "S" shape makes it visually obvious that the missing data follows a pattern, just like real selection bias in statistics.

## Example Output

Here's what your final meme should look like:

![Four-panel statistics meme showing Reality (original image), Your Model (stippled version), Selection Bias (letter S), and Estimate (masked stippled image)](statistics_meme.png)

**Your challenge:** Create a similar meme using your own image, with all code hidden in your `index.qmd` file. The final output should show only the meme image and a brief 1-3 sentence explanation of how it demonstrates selection bias.

## Getting Started: Repository Setup üöÄ

::: {.callout-important}
## üìÅ Repository Setup Instructions

**Step 1:** Fork the starter repository:

- Navigate to [https://github.com/flyaflya/selectionBiasChallenge](https://github.com/flyaflya/selectionBiasChallenge)
- Fork the repository to your GitHub account (this creates `https://github.com/[your-username]/selectionBiasChallenge`)

**Step 2:** Clone your forked repository locally using Cursor (or VS Code)

**Step 3:** Set up GitHub Pages:

- Go to your repository settings (click the "Settings" tab in your GitHub repository)
- Scroll down to the "Pages" section in the left sidebar
- Under "Source", select "Deploy from a branch"
- Choose "main" branch and "/ (root)" folder
- Click "Save"
- Your site will be available at: `https://[your-username].github.io/selectionBiasChallenge/`
- **Note:** It may take a few minutes for the site to become available after enabling Pages

**Step 4:** You're ready to start! Use the `index.qmd` file as your starting point.
:::

## Workflow Overview

This challenge is organized into discrete steps. Steps 1-3 are provided for you. **You must write Steps 4-6 yourself:**

1. **Step 1**: Prepare black and white image (provided) ‚úÖ
2. **Step 2**: Create stippled image using blue noise stippling (provided) ‚úÖ
3. **Step 3**: Create tonal analysis (optional refinement step, provided) ‚úÖ
4. **Step 4**: Create block letter "S" matching image dimensions (**YOU WRITE THIS**) ‚ö†Ô∏è
5. **Step 5**: Create masked image by applying the letter mask to the stippled image (**YOU WRITE THIS**) ‚ö†Ô∏è
6. **Final**: Assemble all components into the four-panel meme (**YOU WRITE THIS**) ‚ö†Ô∏è

**Note:** Step 3 is optional but recommended. It helps you understand your image's brightness distribution and refine the stippling parameters in Step 2 for better results.

## Understanding the Workflow

This challenge uses a modular design where each step is implemented as a discrete function in a separate file. This structure provides several benefits:

### Modular Design Benefits

1. **Modularity**: Each step can be modified independently
2. **Reusability**: Functions can be used in other projects
3. **Testability**: Each function can be tested separately
4. **Clarity**: The workflow is easy to understand and follow
5. **Maintainability**: Changes to one step don't affect others

### Function Files

**Steps you'll use (provided):**
- **`step1_prepare_image.py`**: Image loading and preprocessing
- **`step2_create_stipple.py`**: Blue noise stippling algorithm
- **`step3_create_tonal.py`**: Tonal analysis (optional)

**Steps you'll write:**
- **`step4_create_block_letter.py`**: Block letter generation ‚ö†Ô∏è
- **`step5_create_masked.py`**: Mask application ‚ö†Ô∏è
- **`create_meme.py`**: Final assembly and visualization ‚ö†Ô∏è

**Supporting functions (provided):**
- **`importance_map.py`**: Computes importance map for stippling
- **`stippling_functions.py`**: Core stippling algorithm functions

## Step 1: Prepare Image

Load an image, convert to grayscale, and resize to appropriate dimensions while maintaining aspect ratio.

```{python}
#| label: step1-prepare
#| echo: false
#| fig-cap: "Original image prepared for processing"

import numpy as np
import matplotlib.pyplot as plt
from step1_prepare_image import prepare_image

# Load and prepare the image
# CHANGE THIS to use your own image!
img_path = 'fleischhacker.jpg'  # Example image - replace with your own image
gray_image = prepare_image(img_path, max_size=512)

# Display the prepared image
fig, ax = plt.subplots(figsize=(6.5, 5))
ax.imshow(gray_image, cmap='gray', vmin=0, vmax=1)
ax.axis('off')
ax.set_title('Step 1: Prepared Image', fontsize=14, fontweight='bold', pad=10)
plt.tight_layout()
plt.show()
```

## Step 2: Create Stippled Image

Generate a blue noise stippling pattern from the prepared image. This creates a pattern of dots that preserves visual information while maintaining good spatial distribution.

```{python}
#| label: step2-stipple
#| echo: false
#| fig-cap: "Blue noise stippling pattern"
#| message: false
#| warning: false

from step2_create_stipple import create_stipple

# Create stippled image
stipple_pattern, samples = create_stipple(
    gray_image,
    percentage=0.08,  # 8% of pixels will be stippled
    sigma=0.9,  # Repulsion radius
    content_bias=0.9,  # Strongly follow importance map
    noise_scale_factor=0.1,  # Moderate exploration
    extreme_downweight=0.5,  # Moderate downweighting of extremes
    extreme_threshold_low=0.2,  # Downweight tones below 0.2
    extreme_threshold_high=0.8,  # Downweight tones above 0.8
    extreme_sigma=0.1  # Smooth transition width
)

# Display the stippled image
fig, ax = plt.subplots(figsize=(6.5, 5))
ax.imshow(stipple_pattern, cmap='gray', vmin=0, vmax=1)
ax.axis('off')
ax.set_title('Step 2: Stippled Image', fontsize=14, fontweight='bold', pad=10)
plt.tight_layout()
plt.show()
```

## Step 3: Create Tonal Analysis (Optional Refinement Step)

::: {.callout-note}
## üîß Optional Refinement Step

**Step 3 is optional** but highly recommended! It creates a box-averaged tonal analysis that helps you understand the brightness distribution across your image. Use this information to **tune the stippling parameters in Step 2** for better results.

**How to use it:**
- Analyze the tonal distribution to identify key brightness ranges
- Adjust `extreme_threshold_low` and `extreme_threshold_high` based on your image's tone distribution
- Tune `mid_tone_center` to match important features (e.g., skin tones around 0.7)
- Refine `extreme_downweight` based on how much you want to reduce stipples in extreme regions
:::

Create a tonal analysis by dividing the image into a grid and computing average brightness in each section. This visualizes the distribution of tones and helps identify which brightness ranges are most important.

```{python}
#| label: step3-tonal
#| echo: false
#| fig-cap: "Box-averaged tonal analysis showing brightness distribution"

from step3_create_tonal import create_tonal
import matplotlib.pyplot as plt

# Create tonal analysis with a 16√ó12 grid
grid_rows = 16
grid_cols = 12
tonal_image, average_tones, tonal_stats = create_tonal(
    gray_image,
    grid_rows=grid_rows,
    grid_cols=grid_cols,
    return_full_image=True
)

# Display the box-averaged tonal image with text annotations
fig, ax = plt.subplots(figsize=(6.5, 5))

# Show box-averaged tonal image
ax.imshow(tonal_image, cmap='gray', vmin=0, vmax=1)
ax.axis('off')
ax.set_title('Step 3: Box-Averaged Tonal Analysis', fontsize=14, fontweight='bold', pad=10)

# Calculate grid cell dimensions for text placement
h, w = gray_image.shape
section_h = h / grid_rows
section_w = w / grid_cols

# Add text annotations showing tone values (2 decimals) at the center of each grid cell
for i in range(grid_rows):
    for j in range(grid_cols):
        tone = average_tones[i, j]
        # Calculate center position of the grid cell
        y_center = (i + 0.5) * section_h
        x_center = (j + 0.5) * section_w
        # Use white text for dark sections, black text for light sections
        text_color = 'white' if tone < 0.5 else 'black'
        ax.text(x_center, y_center, f'{tone:.2f}', 
                ha='center', va='center', 
                color=text_color, fontsize=6, fontweight='bold')

plt.tight_layout()
plt.show()

# Print key statistics for parameter tuning
print(f"\nüìä Tonal Statistics for Parameter Tuning:")
print(f"  Mean brightness: {tonal_stats['mean']:.3f}")
print(f"  Standard deviation: {tonal_stats['std']:.3f}")
print(f"  Brightness range: [{tonal_stats['min']:.3f}, {tonal_stats['max']:.3f}]")
print(f"\nüí° Tuning Tips:")
print(f"  - If mean < 0.4: Image is dark, consider lowering extreme_threshold_low")
print(f"  - If mean > 0.6: Image is light, consider raising extreme_threshold_high")
print(f"  - If std > 0.2: High contrast, may need stronger extreme_downweight")
print(f"  - Use mid_tone_center around {tonal_stats['mean']:.2f} to emphasize average tones")
```

## Step 4: Create Block Letter "S" ‚ö†Ô∏è **YOUR TASK**

::: {.callout-warning}
## üéØ Your Challenge: Write `step4_create_block_letter.py`

**Task:** Create a function `create_block_letter_s()` that generates a block letter "S" matching your image dimensions.

**Requirements:**
- Function signature: `create_block_letter_s(height: int, width: int, letter: str = "S", font_size_ratio: float = 0.9) -> np.ndarray`
- Returns a 2D numpy array (height √ó width) with values in [0, 1]
- The letter should be black (0.0) on a white background (1.0)
- The letter should be centered and scaled appropriately to fit within the image
- Use PIL/Pillow's ImageDraw or similar to render the letter

**Hints:**
- You can use `PIL.Image` and `PIL.ImageDraw` to draw text
- Try multiple font paths (e.g., system fonts) if one doesn't work
- Make the letter bold and large enough to be clearly visible
- The letter represents the "selection bias" pattern in your meme
:::

**Your code should go in a file called `step4_create_block_letter.py`.** Once you've written it, you'll use it like this:

```{python}
#| label: step4-block-letter
#| echo: false
#| fig-cap: "Block letter S representing selection bias"
#| eval: false

# UNCOMMENT AND USE THIS ONCE YOU'VE WRITTEN step4_create_block_letter.py:
# from step4_create_block_letter import create_block_letter_s
# 
# # Get image dimensions
# h, w = gray_image.shape
# 
# # Create block letter S
# block_letter = create_block_letter_s(h, w, letter="S", font_size_ratio=0.9)
# 
# # Display the block letter
# fig, ax = plt.subplots(figsize=(6.5, 5))
# ax.imshow(block_letter, cmap='gray', vmin=0, vmax=1)
# ax.axis('off')
# ax.set_title('Step 4: Selection Bias (Block Letter S)', fontsize=14, fontweight='bold', pad=10)
# plt.tight_layout()
# plt.show()
```

## Step 5: Create Masked Image ‚ö†Ô∏è **YOUR TASK**

::: {.callout-warning}
## üéØ Your Challenge: Write `step5_create_masked.py`

**Task:** Create a function `create_masked_stipple()` that applies the block letter mask to the stippled image.

**Requirements:**
- Function signature: `create_masked_stipple(stipple_img: np.ndarray, mask_img: np.ndarray, threshold: float = 0.5) -> np.ndarray`
- Returns a 2D numpy array with the same shape as the input images
- Where the mask is dark (below threshold), remove stipples (set to white/1.0)
- Where the mask is light (above threshold), keep the stipples as they are
- This creates the "biased estimate" by systematically removing data points

**Hints:**
- The mask image has values in [0, 1] where 0.0 = black (mask area) and 1.0 = white (keep area)
- Use numpy boolean indexing or np.where() to apply the mask
- The threshold determines what counts as "part of the mask"
:::

**Your code should go in a file called `step5_create_masked.py`.** Once you've written it, you'll use it like this:

```{python}
#| label: step5-masked
#| echo: false
#| fig-cap: "Masked stippled image showing selection bias effect"
#| eval: false

# UNCOMMENT AND USE THIS ONCE YOU'VE WRITTEN step5_create_masked.py:
# from step5_create_masked import create_masked_stipple
# 
# # Create masked stippled image
# masked_stipple = create_masked_stipple(
#     stipple_pattern,
#     block_letter,
#     threshold=0.5  # Pixels below 0.5 are considered part of the mask
# )
# 
# # Display the masked image
# fig, ax = plt.subplots(figsize=(6.5, 5))
# ax.imshow(masked_stipple, cmap='gray', vmin=0, vmax=1)
# ax.axis('off')
# ax.set_title('Step 5: Masked Stippled Image (Estimate)', fontsize=14, fontweight='bold', pad=10)
# plt.tight_layout()
# plt.show()
```

## Create the Final Statistics Meme ‚ö†Ô∏è **YOUR TASK**

::: {.callout-warning}
## üéØ Your Challenge: Write `create_meme.py`

**Task:** Create a function `create_statistics_meme()` that assembles all four panels into a professional-looking meme.

**Requirements:**
- Function signature: `create_statistics_meme(original_img: np.ndarray, stipple_img: np.ndarray, block_letter_img: np.ndarray, masked_stipple_img: np.ndarray, output_path: str, dpi: int = 150, background_color: str = "white") -> None`
- Creates a 1√ó4 layout (four panels side by side)
- Each panel should be labeled: "Reality", "Your Model", "Selection Bias", "Estimate"
- Save the result as a PNG file
- Make it look professional with good spacing, labels, and layout

**Hints:**
- Use matplotlib's `subplots()` or `GridSpec` to create the layout
- Add text labels above or below each panel
- Consider adding a border or background color
- Use high DPI (150-300) for publication quality
- Make sure all images are the same size or handle resizing appropriately
:::

**Your code should go in a file called `create_meme.py`.** Once you've written it, you'll use it like this:

```{python}
#| label: create-final-meme
#| echo: false
#| eval: false

# UNCOMMENT AND USE THIS ONCE YOU'VE WRITTEN create_meme.py:
# from create_meme import create_statistics_meme
# 
# # Create the final meme
# create_statistics_meme(
#     original_img=gray_image,
#     stipple_img=stipple_pattern,
#     block_letter_img=block_letter,
#     masked_stipple_img=masked_stipple,
#     output_path="my_statistics_meme.png",
#     dpi=150,
#     background_color="white"  # or "pink", "lightgray", etc.
# )
```

## My Final Submission


** FILE 1 ‚Äî step4_create_block_letter.py (unchanged from starter file which is the same as the one in the repository)

```{python}
import numpy as np
from PIL import Image, ImageDraw, ImageFont

def create_block_letter_s(height: int,
                          width: int,
                          letter: str = "S",
                          font_size_ratio: float = 0.9) -> np.ndarray:
    """
    Creates a grayscale block letter mask (black letter on white background)
    of the specified dimensions, representing the systematic missing data pattern.
    """

    img = Image.new("L", (width, height), color=255)
    draw = ImageDraw.Draw(img)

    # List of common font paths for cross-platform compatibility
    font_paths = [
        "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
        "/Library/Fonts/Arial Bold.ttf",
        "C:/Windows/Fonts/arialbd.ttf"
    ]

    font = None
    for fp in font_paths:
        try:
            # Load a bold font, scaled based on the minimum dimension
            font = ImageFont.truetype(fp, int(min(height, width) * font_size_ratio))
            break
        except:
            pass

    if font is None:
        font = ImageFont.load_default()

    text = letter.upper()
    # Calculate text position to center it
    text_bbox = draw.textbbox((0, 0), text, font=font)
    text_w = text_bbox[2] - text_bbox[0]
    text_h = text_bbox[3] - text_bbox[1]

    pos_x = (width - text_w) // 2
    pos_y = (height - text_h) // 2

    # Draw the letter in black (fill=0) on the white background
    draw.text((pos_x, pos_y), text, fill=0, font=font)

    # Convert to a NumPy array normalized to [0, 1] (0.0=black, 1.0=white)
    mask = np.array(img).astype(float) / 255.0
    return mask

```

** FILE 2 ‚Äî step5_create_masked.py (unchanged from starter file which is the same as the one in the repository)

```{python}
import numpy as np

def create_masked_stipple(stipple_img: np.ndarray,
                          mask_img: np.ndarray,
                          threshold: float = 0.5) -> np.ndarray:
    """
    Applies a block letter mask (representing systematic missing data) 
    to the stippled image (representing sampled data).
    
    Where the mask is dark (below threshold), the stipples are removed (set to white/1.0).
    """

    # Use np.where to conditionally replace pixel values.
    # If mask_img < threshold (i.e., it's part of the black 'S'), set the output pixel to 1.0 (white/missing data).
    # Otherwise, keep the original stipple_img pixel value.
    masked = np.where(mask_img < threshold, 1.0, stipple_img)
    return masked
```


** FILE 3 ‚Äî create_meme.py
```{python}
import numpy as np
import matplotlib.pyplot as plt

def create_statistics_meme(
        original_img: np.ndarray,
        stipple_img: np.ndarray,
        block_letter_img: np.ndarray,
        masked_stipple_img: np.ndarray,
        output_path: str,
        dpi: int = 150,
        background_color: str = "white") -> None:
    """
    Assembles the four processed images into a single 1x4 panel statistics meme
    and saves the result to the specified output path.
    """

    fig, axes = plt.subplots(1, 4, figsize=(16, 4), dpi=dpi)
    fig.patch.set_facecolor(background_color)

    panels = [
        ("Reality", original_img),
        ("Your Model", stipple_img),
        ("Selection Bias", block_letter_img),
        ("Estimate", masked_stipple_img)
    ]

    for ax, (title, img) in zip(axes, panels):
        ax.imshow(img, cmap="gray", vmin=0, vmax=1)
        ax.set_title(title, fontsize=14, fontweight="bold", pad=10)
        ax.axis("off") # Remove axis ticks and labels

    plt.tight_layout()
    plt.savefig(output_path, dpi=dpi, bbox_inches="tight", facecolor=background_color)
    plt.close()
```

# Step 1
```{python}
from step1_prepare_image import prepare_image
# Assume 'ImageNeetekKumar.jpg' is in your directory
gray_image = prepare_image("ImageNeetekKumar.jpg", max_size=512)
h, w = gray_image.shape

# Display for Step 1
import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(6.5, 5))
ax.imshow(gray_image, cmap='gray', vmin=0, vmax=1)
ax.axis('off')
ax.set_title('Step 1: Prepared Image (Reality)', fontsize=14, fontweight='bold', pad=10)
plt.tight_layout()
plt.show()
```

# Step 2
```{python}
from step2_create_stipple import create_stipple
# Use default parameters for stippling
stipple_pattern, samples = create_stipple(gray_image, percentage=0.08)

# Display for Step 2
import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(6.5, 5))
ax.imshow(stipple_pattern, cmap='gray', vmin=0, vmax=1)
ax.axis('off')
ax.set_title('Step 2: Stippled Image (Your Model)', fontsize=14, fontweight='bold', pad=10)
plt.tight_layout()
plt.show()
```

# Step 3 
```{python}
from step3_create_tonal import create_tonal
import matplotlib.pyplot as plt

# Create tonal analysis
grid_rows = 16
grid_cols = 12
tonal_image, average_tones, tonal_stats = create_tonal(
    gray_image,
    grid_rows=grid_rows,
    grid_cols=grid_cols,
    return_full_image=True
)

# Display the tonal image
fig, ax = plt.subplots(figsize=(6.5, 5))
ax.imshow(tonal_image, cmap='gray', vmin=0, vmax=1)
ax.axis('off')
ax.set_title('Step 3: Box-Averaged Tonal Analysis', fontsize=14, fontweight='bold', pad=10)

# Calculate grid cell dimensions for text placement
h_img, w_img = gray_image.shape
section_h = h_img / grid_rows
section_w = w_img / grid_cols

# Add text annotations showing tone values (2 decimals)
for i in range(grid_rows):
    for j in range(grid_cols):
        tone = average_tones[i, j]
        y_center = (i + 0.5) * section_h
        x_center = (j + 0.5) * section_w
        text_color = 'white' if tone < 0.5 else 'black'
        ax.text(x_center, y_center, f'{tone:.2f}', 
                ha='center', va='center', 
                color=text_color, fontsize=6, fontweight='bold')

plt.tight_layout()
plt.show()

# Print key statistics for parameter tuning
print(f"\nüìä Tonal Statistics for Parameter Tuning:")
print(f"  Mean brightness: {tonal_stats['mean']:.3f}")
print(f"  Standard deviation: {tonal_stats['std']:.3f}")
print(f"  Brightness range: [{tonal_stats['min']:.3f}, {tonal_stats['max']:.3f}]")
print(f"\nüí° Tuning Tips:")
print(f"  - If mean < 0.4: Image is dark, consider lowering extreme_threshold_low")
print(f"  - If mean > 0.6: Image is light, consider raising extreme_threshold_high")
print(f"  - If std > 0.2: High contrast, may need stronger extreme_downweight")
print(f"  - Use mid_tone_center around {tonal_stats['mean']:.2f} to emphasize average tones")
```

# Step 4

```{python}
#| label: step4-block-letter
#| echo: false
#| fig-cap: "Block letter S representing selection bias"

# Import the function from step4_create_block_letter.py (or define inline)
try:
    from step4_create_block_letter import create_block_letter_s
except ImportError:
    # Define the function if the file doesn't exist
    import numpy as np
    from PIL import Image, ImageDraw, ImageFont
    
    def create_block_letter_s(height: int,
                              width: int,
                              letter: str = "S",
                              font_size_ratio: float = 0.9) -> np.ndarray:
        """
        Creates a grayscale block letter mask (black letter on white background)
        of the specified dimensions, representing the systematic missing data pattern.
        """
        img = Image.new("L", (width, height), color=255)
        draw = ImageDraw.Draw(img)
        
        font_paths = [
            "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
            "/Library/Fonts/Arial Bold.ttf",
            "C:/Windows/Fonts/arialbd.ttf"
        ]
        
        font = None
        for fp in font_paths:
            try:
                font = ImageFont.truetype(fp, int(min(height, width) * font_size_ratio))
                break
            except:
                pass
        
        if font is None:
            font = ImageFont.load_default()
        
        text = letter.upper()
        text_bbox = draw.textbbox((0, 0), text, font=font)
        text_w = text_bbox[2] - text_bbox[0]
        text_h = text_bbox[3] - text_bbox[1]
        
        pos_x = (width - text_w) // 2
        pos_y = (height - text_h) // 2
        
        draw.text((pos_x, pos_y), text, fill=0, font=font)
        mask = np.array(img).astype(float) / 255.0
        return mask

# Get image dimensions
h, w = gray_image.shape

print("üé® Step 4: Creating Selection Bias Pattern")
print("=" * 50)
print(f"üìê Image Dimensions:")
print(f"   Height: {h} pixels")
print(f"   Width: {w} pixels")
print(f"   Total pixels: {h * w:,}")
print()

# Create block letter mask
block_letter = create_block_letter_s(h, w, letter="S")

# Calculate mask statistics
mask_pixels = np.sum(block_letter < 0.5)  # Count black pixels (the letter)
total_pixels = block_letter.size
mask_percentage = (mask_pixels / total_pixels) * 100
white_pixels = total_pixels - mask_pixels
white_percentage = (white_pixels / total_pixels) * 100

print(f"üìä Block Letter Mask Statistics:")
print(f"   Mask area (black 'S'): {mask_pixels:,} pixels ({mask_percentage:.2f}%)")
print(f"   Background (white): {white_pixels:,} pixels ({white_percentage:.2f}%)")
print()
print(f"‚ö†Ô∏è  This 'S' pattern represents the systematic missing data!")
print(f"   When applied, it will remove {mask_percentage:.2f}% of the image area.")
print("=" * 50)
print()

# Display
import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(6.5, 5))
ax.imshow(block_letter, cmap='gray', vmin=0, vmax=1)
ax.axis('off')
ax.set_title('Step 4: Block Letter Mask (S)', fontsize=14, fontweight='bold', pad=10)
plt.tight_layout()
plt.show()
```



# Step 5


```{python}
#| label: step5-masked
#| echo: false
#| fig-cap: "Masked stippled image showing selection bias effect"

import numpy as np
import matplotlib.pyplot as plt

# Define the function inline (or import if step5_create_masked.py exists)
try:
    from step5_create_masked import create_masked_stipple
except ImportError:
    # Define the function if the file doesn't exist
    def create_masked_stipple(stipple_img: np.ndarray,
                              mask_img: np.ndarray,
                              threshold: float = 0.5) -> np.ndarray:
        """
        Applies a block letter mask (representing systematic missing data) 
        to the stippled image (representing sampled data).
        
        Where the mask is dark (below threshold), the stipples are removed (set to white/1.0).
        """
        masked = np.where(mask_img < threshold, 1.0, stipple_img)
        return masked

# Apply the block letter mask to the stippled image
print("üîç Step 5: Applying Selection Bias Mask")
print("=" * 50)

# Calculate statistics before masking
stipple_pixels = np.sum(stipple_pattern < 0.5)  # Count black pixels (stipples)
total_pixels = stipple_pattern.size
stipple_percentage = (stipple_pixels / total_pixels) * 100

print(f"üìä Stippled Image Statistics:")
print(f"   Total pixels: {total_pixels:,}")
print(f"   Stipple points (black pixels): {stipple_pixels:,}")
print(f"   Stipple coverage: {stipple_percentage:.2f}%")
print()

# Create masked stippled image
masked_stipple = create_masked_stipple(
    stipple_pattern,
    block_letter,
    threshold=0.5  # Pixels below 0.5 are considered part of the mask
)

# Calculate statistics after masking
masked_pixels = np.sum(masked_stipple < 0.5)  # Count remaining stipples
masked_percentage = (masked_pixels / total_pixels) * 100
removed_pixels = stipple_pixels - masked_pixels
removed_percentage = (removed_pixels / stipple_pixels) * 100

print(f"üìä Masked Image Statistics:")
print(f"   Remaining stipple points: {masked_pixels:,}")
print(f"   Remaining coverage: {masked_percentage:.2f}%")
print(f"   Removed stipple points: {removed_pixels:,}")
print(f"   Data loss: {removed_percentage:.2f}%")
print()
print(f"‚ö†Ô∏è  Selection bias has removed {removed_percentage:.1f}% of the data points!")
print("=" * 50)
print()

# Display the masked stippled image
fig, ax = plt.subplots(figsize=(6.5, 5))
ax.imshow(masked_stipple, cmap='gray', vmin=0, vmax=1)
ax.axis('off')
ax.set_title('Step 5: Masked Stippled Image (Estimate)', fontsize=14, fontweight='bold', pad=10)
plt.tight_layout()
plt.show()
```

This version:
1. Imports the function from `step5_create_masked.py`
2. Prints statistics before and after masking
3. Shows data loss percentage
4. Displays the masked image

The print statements show:
- Total pixels and stipple coverage before masking
- Remaining stipples and data loss after masking
- A warning about the selection bias effect

Make sure `step5_create_masked.py` exists in your directory with the `create_masked_stipple` function.

```

# Step 6
```{python}
import numpy as np
import matplotlib.pyplot as plt

def create_statistics_meme(
        original_img: np.ndarray,
        stipple_img: np.ndarray,
        block_letter_img: np.ndarray,
        masked_stipple_img: np.ndarray,
        output_path: str,
        dpi: int = 150,
        background_color: str = "white") -> None:
    """
    Assembles the four processed images into a single 1x4 panel statistics meme
    and saves the result to the specified output path.
    """

    fig, axes = plt.subplots(1, 4, figsize=(16, 4), dpi=dpi)
    fig.patch.set_facecolor(background_color)

    panels = [
        ("Reality", original_img),
        ("Your Model", stipple_img),
        ("Selection Bias", block_letter_img),
        ("Estimate", masked_stipple_img)
    ]

    for ax, (title, img) in zip(axes, panels):
        ax.imshow(img, cmap="gray", vmin=0, vmax=1)
        ax.set_title(title, fontsize=14, fontweight="bold", pad=10)
        ax.axis("off") # Remove axis ticks and labels

    plt.tight_layout()
    plt.savefig(output_path, dpi=dpi, bbox_inches="tight", facecolor=background_color)
    plt.close()

    # Display the final image for the Quarto output
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

img = mpimg.imread("my_statistics_meme.png")
fig, ax = plt.subplots(figsize=(16, 4))
ax.imshow(img)
ax.axis('off')
plt.tight_layout()
plt.show()

```

# Elaborate on the meme and the selection bias.

This four-panel meme is designed as a direct visual metaphor to illustrate the statistical concept of Selection Bias, which occurs when the sample data collected is not representative of the true population.

 Elaborate Explanation: Visualizing Selection BiasThis four-panel meme is designed as a direct visual metaphor to illustrate the statistical concept of Selection Bias, which occurs when the sample data collected is not representative of the true population.
 
 **Key Components of the Meme**
 
 The image workflow mimics the process of moving from an objective reality to a biased statistical estimate:
 
 **Reality (Original Image):** This represents the true population or the complete data structure we are trying to study. Since it is the original image, it contains $100\%$ of the information and is free from error or sampling effects.
 
 **Model (Stippled Image):** This panel represents the process of data collection or sampling. The stippling algorithm converts the continuous tones of the image into discrete dots (data points). While the pattern retains the overall visual information, it is only a sample of the pixels, analogous to collecting data points (observations) from a population. This is the dataset available to the statistician.
 
 **Selection Bias (Block Letter "S" Mask):** This is the crucial step. The bold letter "S" represents a systematic, non-random pattern of missing data (the "Selection" in selection bias). In real-world statistics, this pattern might be caused by factors like survey non-response from a specific demographic or technical limitations that systematically exclude certain types of observations.
 
 **Estimate (Masked Stippled Image):** This panel shows the final dataset after the selection bias is applied. The "S"-shaped missing patch severely distorts the visual information and the underlying pattern of the stippled image. This visually demonstrates the outcome of selection bias: the conclusion or estimate drawn from the remaining data is biased and no longer accurately reflects the original Reality.



### Complete Checklist

To complete this challenge, you must:

1. ‚úÖ **Use Step 1** to prepare your own image (with your own image file)
2. ‚úÖ **Use Step 2** to generate a stippled image using blue noise stippling
3. ‚≠ê **Optionally use Step 3** to analyze tonal distribution and refine Step 2 parameters (recommended)
4. ‚ö†Ô∏è **Write Step 4**: Create `step4_create_block_letter.py` to generate the block letter "S"
5. ‚ö†Ô∏è **Write Step 5**: Create `step5_create_masked.py` to apply the mask
6. ‚ö†Ô∏è **Write Final Step**: Create `create_meme.py` to assemble the four-panel meme
7. ‚úÖ **Create a complete `index.qmd`** that uses all functions (with code hidden)
8. ‚úÖ **Generate your final meme** using your own image
9. ‚úÖ **Include a brief explanation** (1-3 sentences) of how the meme demonstrates selection bias

### Final Output Requirements

**Important:** All code should be hidden (`echo: false`) in your final `index.qmd` output. The rendered HTML should show only:
- The final meme image
- A brief explanation (1-3 sentences) of how it demonstrates selection bias

### Template for Final Section

Here's a template for your final section:

```{python}
#| label: final-meme
#| echo: false
#| eval: false
#| fig-cap: "Statistics meme demonstrating selection bias"

# Your code to create and display the meme goes here
# (all the steps above, uncommented and working)

# Display the final meme
# from IPython.display import Image, display
# display(Image("my_statistics_meme.png"))
```

### Example Explanation

Your explanation should be 1-3 sentences. Here's an example:

> This meme demonstrates selection bias by showing how systematic missing data patterns distort our understanding of reality. The original image (Reality) represents the true population, while the stippled version (Your Model) shows our data collection. When selection bias removes data points in a systematic "S" pattern, the resulting estimate becomes biased and no longer represents the true population, just as missing data in real-world studies can lead to incorrect conclusions.

## Tips for Success

1. **Image Selection**: Choose an image with good contrast for best stippling results
2. **Use Tonal Analysis**: Run Step 3 to understand your image's brightness distribution, then refine Step 2 parameters
3. **Function Design**: Write clean, well-documented functions with clear parameter types and return values
4. **Test Incrementally**: Test each function separately before integrating them
5. **Professional Output**: Make your meme look polished with good labels, spacing, and layout
6. **Code Organization**: Keep your functions in separate `.py` files as specified
7. **Documentation**: Add docstrings to your functions explaining parameters and return values

## Conclusion

By completing this challenge, you'll have created a memorable visual representation of selection bias that demonstrates how systematic missing data patterns can distort our understanding of reality. The skills you've practiced‚Äîwriting modular Python functions, image processing, and creating professional visualizations‚Äîare directly applicable to real-world data analysis projects.

As you work with real datasets, remember the lesson of this meme: when data is missing in a systematic pattern rather than randomly, your estimates become biased. Recognizing and addressing selection bias is crucial for drawing valid conclusions from your data.

